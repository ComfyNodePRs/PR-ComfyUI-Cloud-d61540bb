import os
import sys
import types

PINLINED_DEFAULT_PACKAGE = '%{DEFAULT_PACKAGE}'
PINLINER_MODULE_NAME = 'pinliner_loader'
loader_version = '0.2.1'

FORCE_EXC_HOOK = %{FORCE_EXC_HOOK}

inliner_importer_code = '''
import imp

import sys
import os
import types
import importlib.abc
import importlib.machinery
import marshal
import struct


class InlinerImporter(object):
    def __init__(self, data, datafile, set_excepthook=True):
        self.data = data
        self.datafile = datafile

    def _get_code(self, fullname):
        __, start, end, ts = self.data[fullname]
        with open(self.datafile, 'rb') as datafile:
            datafile.seek(start)
            code = datafile.read(end - start).decode('utf-8')
        return code

    def _is_parent_module(self, fullname):
        if self.data[fullname][0] == 0 and self.data[fullname][1] == 0 and self.data[fullname][2] == 0 and self.data[fullname][3] == 0:
            return True
        else:
            return False

    def find_spec(self, fullname, path, target=None):
        if fullname in self.data:
            # @monkey patch
            # is a dir
            if self._is_parent_module(fullname):
                spec = importlib.util.spec_from_loader(fullname, self)
                spec.submodule_search_locations = list(self.data.keys()) # This defines the packages' subpackage routes

                return spec

            else:
                return importlib.machinery.ModuleSpec(fullname, self)
    
    def create_module(self, spec):
        return None

    def exec_module(self, module):
        # If the module is already in there, we'll reload but won't remove the
        # entry if we fail
        fullname = module.__name__

        # @monkey patch
        # Ignore if it is only searching for dir name
        if self._is_parent_module(fullname):
          return

        exists = fullname in sys.modules

        module = types.ModuleType(fullname)
        module.__loader__ = self

        is_package = self.data[fullname][0]
        path = fullname.replace('.', os.path.sep)
        if is_package:
            module.__package__ = fullname
            module.__file__ = os.path.join(path, '__init__.py')
            module.__path__ = [path]
        else:
            module.__package__ = fullname.rsplit('.', 1)[0]
            module.__file__ = path + '.py'

        sys.modules[fullname] = module

        try:
            compiled_code = self._get_code(module.__name__)
            exec(compiled_code, module.__dict__)
        except Exception:
            if not exists:
                del sys.modules[fullname]
            raise

        return module
    
''' % {'loader_version': loader_version}

${CONTENTS}

def prepare_package():
    # Loader's module name changes with each major version to be able to have
    # different loaders working at the same time.
    module_name = PINLINER_MODULE_NAME + '_' + loader_version.split('.')[0]

    # If the loader code is not already loaded we create a specific module for
    # it.  We need to do it this way so that the functions in there are not
    # compiled with a reference to this module's global dictionary in
    # __globals__.
    module = sys.modules.get(module_name)
    if not module:
        module = types.ModuleType(module_name)
        module.__package__ = ''
        module.__file__ = module_name + '.py'
        exec(inliner_importer_code, module.__dict__)
        sys.modules[module_name] = module

    # We cannot use __file__ directly because on the second run __file__ will
    # be the compiled file (.pyc) and that's not the file we want to read.
    filename = os.path.splitext(__file__)[0] + '.py'

    # Add our own finder and loader for this specific package if it's not
    # already there.
    # This must be done before we initialize the package, as it may import
    # packages and modules contained in the package itself.
    for finder in sys.meta_path:
        if (isinstance(finder, module.InlinerImporter) and
                finder.data == inliner_packages):
            importer = finder
    else:
        # If we haven't forced the setting of the uncaught exception handler
        # we replace it only if it hasn't been replace yet, this is because
        # CPython default handler does not use traceback or even linecache, so
        # it never calls get_source method to get the code, but for example
        # iPython does, so we don't need to replace the handler.
        if FORCE_EXC_HOOK is None:
            set_excepthook = sys.__excepthook__ == sys.excepthook
        else:
            set_excepthook = FORCE_EXC_HOOK

        importer = module.InlinerImporter(inliner_packages, filename,
                                          set_excepthook)
        sys.meta_path.append(importer)

    # If this is a bundle (multiple packages) without default then don't import
    # any package automatically.
    if not PINLINED_DEFAULT_PACKAGE:
        return

    __, start, end, ts = inliner_packages[PINLINED_DEFAULT_PACKAGE]
    with open(filename) as datafile:
        datafile.seek(start)
        code = datafile.read(end - start)

    # We need everything to be local variables before we clear the global dict
    def_package = PINLINED_DEFAULT_PACKAGE
    name = __name__
    filename = def_package + '/__init__.py'
    compiled_code = compile(code, filename, 'exec')

    # Prepare globals to execute __init__ code
    #globals().clear()
    # If we've been called directly we cannot set __path__
    if name != '__main__':
        globals()['__path__'] = [def_package]
    else:
        def_package = None
    globals().update(__file__=filename,
                     __package__=def_package,
                     __name__=name,
                     __loader__=importer)

    exec(compiled_code, globals())


# Prepare loader's module and populate this namespace only with package's
# __init__
prepare_package()
